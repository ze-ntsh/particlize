<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="Particlize - A 3D particle system visualization" />
    <meta name="keywords" content="particles, 3D, animation, visualization, WebGL, three.js" />
    <title>Particlize</title>
    <link rel="stylesheet" href="style.css" />
  </head>
  <body>
    <div class="app">
      <canvas id="particle-canvas">
        <p>Your browser does not support the HTML5 canvas element.</p>
      </canvas>
    </div>
  </body>

  <script type="module">
    import { ParticleSystem, Particle } from "./src";
    import { SamplerFrame } from "./src/frames";
    import { textToMesh } from "./src/utils";
    import { MeshSurfaceSampler } from "./src/samplers";
    import * as THREE from "three";
    import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";

    const canvas = document.getElementById("particle-canvas");

    const ps = new ParticleSystem({
      canvas: canvas,
      preWarm: true,
      maxParticles: 100000,
      backgroundColor: [0.0, 0.0, 0.0, 1.0], // Dark background
    });
    // Create three concentric sphere meshes
    const sphereRadii = [0.8, 1.5, 2.3]; // Radii for 3 concentric spheres
    const sphereColors = [
      0xff0000, // Red (inner)
      0x00ff00, // Green (middle)
      0x0000ff, // Blue (outer)
    ];

    // Create particles from mesh surfaces
    const sphereParticles = [];
    const particlesPerSphere = Math.floor(100000 / sphereRadii.length);

    for (let i = 0; i < sphereRadii.length; i++) {
      // Create sphere geometry and material
      const geometry = new THREE.SphereGeometry(sphereRadii[i], 32, 32);
      const material = new THREE.MeshBasicMaterial({ color: sphereColors[i] });
      const mesh = new THREE.Mesh(geometry, material);

      ps.addParticles(
        new SamplerFrame({
          sampler: new MeshSurfaceSampler(mesh),
          count: particlesPerSphere,
        })
      );
    }

    // const loader = new GLTFLoader();
    // const loadGLTF = (url) =>
    //   new Promise((resolve, reject) => {
    //     loader.load(
    //       url,
    //       (gltf) => resolve(gltf.scene),
    //       undefined,
    //       (error) => reject(error)
    //     );
    //   });

    // (async () => {
    //   try {
    //     const loadedScene = await loadGLTF("assets/dragon/scene.gltf");

    //     // Log the entire scene structure
    //     console.log("Loaded scene:", loadedScene);
    //     console.log("Direct children:", loadedScene.children);

    //     // Recursively find meshes in the scene
    //     const meshes = [];
    //     loadedScene.traverse((child) => {
    //       if (child instanceof THREE.Mesh) {
    //         meshes.push(child);
    //         console.log("Found mesh in traversal:", child);
    //       }
    //     });

    //     if (meshes.length > 0) {
    //       console.log("Found meshes:", meshes);
    //       const mesh = meshes[0]; // Use the first mesh found

    //       // Scale the mesh (zoom)
    //       mesh.scale.set(1.5, 1.5, 1.5); // Adjust scale factor as needed

    //       // Center the mesh
    //       const box = new THREE.Box3().setFromObject(mesh);
    //       const center = box.getCenter(new THREE.Vector3());
    //       mesh.position.sub(center); // Center the mesh at origin

    //       mesh.rotation.set(0, Math.PI / 2, 0); // Rotate the mesh to face the camera

    //       const sampler = new MeshSurfaceSampler(mesh);

    //       ps.addParticles(
    //         new Particlizer({
    //           sampler: sampler,
    //           texture: "assets/dragon/3DModel_1_BaseColor.jpeg",
    //           count: 20000,
    //         })
    //       );
    //     } else {
    //       console.warn("No meshes found in the model");
    //     }
    //   } catch (error) {
    //     console.error("Failed to load GLTF:", error);
    //   }
    // })();

    ps.start();
  </script>
</html>
